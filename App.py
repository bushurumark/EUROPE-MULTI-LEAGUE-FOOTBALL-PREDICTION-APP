# -*- coding: utf-8 -*-
"""flask.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cQ4AG3inLfPrMbt_WBZhMki_HXFyMMmn
"""

from flask import Flask, render_template, request, session, url_for, redirect
import pandas as pd
import joblib
import gdown
import plotly.express as px
from sklearn.metrics import accuracy_score, confusion_matrix
import os
import json

app = Flask(__name__)
app.secret_key = os.getenv("FLASK_SECRET_KEY")
# Download and cache models
def download_models():
    # Model 1
    url1 = 'https://drive.google.com/uc?id=1uchT3FyZuGOBv9LTbxbm9gTynoWZ8HGk'
    output1 = 'model1.pkl'
    if not os.path.exists(output1):
        gdown.download(url1, output1, quiet=False)
    model1 = joblib.load(output1)

    # Model 2
    url2 = 'https://drive.google.com/uc?id=10zj3fK-2YYjgQGj3HvPWHc6PtXTmyX61'
    output2 = 'model2.pkl'
    if not os.path.exists(output2):
        gdown.download(url2, output2, quiet=False)
    model2 = joblib.load(output2)

    return model1, model2

# Load data
def load_data():
    # Dataset 1
    url1 = 'https://drive.google.com/uc?id=1Xu3bpecWmhd0ZE9P2oLaalce9nTBV5Zx'
    output1 = 'football_data1.csv'
    if not os.path.exists(output1):
        gdown.download(url1, output1, quiet=False)
    data1 = pd.read_csv(output1)

    # Dataset 2
    url2 = 'https://drive.google.com/uc?id=1ZtmML4-kYhVffOSxRLw6QhA9uUDqlqoy'
    output2 = 'football_data2.csv'
    if not os.path.exists(output2):
        gdown.download(url2, output2, quiet=False)
    data2 = pd.read_csv(output2)

    return data1, data2

# Initialize models and data
model1, model2 = download_models()
data1, data2 = load_data()

# League data structure
leagues = {
    'European Leagues': {
        "Premier League": sorted(['Arsenal', 'Aston Villa', 'Bournemouth', 'Brentford', 'Brighton', 'Chelsea', 'Crystal Palace',
                                  'Everton', 'Fulham', 'Ipswich', 'Leicester', 'Liverpool', 'Man City', 'Man United', 'Newcastle',
                                  "Nott'm Forest", 'Southampton', 'Tottenham', 'West Ham', 'Wolves']),
        "English Championship": sorted(['Blackburn', 'Derby', 'Preston', 'Sheffield United', 'Cardiff', 'Sunderland','Hull',
                                         'Bristol City', 'Leeds', 'Portsmouth', 'Middlesbrough', 'Swansea','Millwall', 'Watford',
                                         'Oxford', 'Norwich', 'QPR', 'West Brom', 'Stoke','Coventry', 'Sheffield Weds', 'Plymouth',
                                         'Luton', 'Burnley']),
        "Serie A": sorted(['Atalanta', 'Bologna', 'Cagliari', 'Como', 'Empoli', 'Fiorentina', 'Genoa', 'Inter',
                           'Juventus', 'Lazio', 'Lecce', 'Milan', 'Monza', 'Napoli', 'Parma', 'Roma', 'Torino',
                           'Udinese', 'Venezia', 'Verona']),
        "Serie B": sorted(['Bari', 'Brescia', 'Carrarese', 'Catanzaro', 'Cesena', 'Cittadella', 'Cosenza', 'Cremonese',
                           'Frosinone', 'Juve Stabia', 'Mantova', 'Modena', 'Palermo', 'Pisa', 'Reggiana', 'Salernitana',
                           'Sampdoria', 'Sassuolo', 'Spezia', 'Sudtirol']),
        "Ligue1": sorted(['Angers', 'Auxerre', 'Brest', 'Lens', 'Le Havre', 'Lille', 'Lyon', 'Marseille',
                          'Monaco', 'Montpellier', 'Nantes', 'Nice', 'Paris SG', 'Reims', 'Rennes',
                          'St Etienne', 'Strasbourg', 'Toulouse']),
        "Ligue2": sorted(['Ajaccio', 'Rodez', 'Amiens', 'Red Star', 'Clermont', 'Pau FC', 'Dunkerque',
                          'Annecy', 'Grenoble', 'Laval', 'Guingamp', 'Troyes', 'Caen', 'Paris FC',
                          'Martigues', 'Lorient', 'Metz', 'Bastia']),
        "La Liga": sorted(['Alaves', 'Ath Bilbao', 'Ath Madrid', 'Barcelona', 'Betis', 'Celta', 'Espanol', 'Getafe',
                           'Girona', 'Las Palmas', 'Leganes', 'Mallorca', 'Osasuna', 'Real Madrid', 'Sevilla', 'Sociedad',
                           'Valencia', 'Valladolid', 'Vallecano', 'Villarreal']),
        "La Liga2": sorted(['Albacete', 'Almeria', 'Burgos', 'Cadiz', 'Cartagena', 'Castellon', 'Cordoba', 'Eibar',
                            'Eldense', 'Elche', 'Ferrol', 'Granada', 'Huesca', 'La Coruna', 'Levante', 'Malaga',
                            'Mirandes', 'Oviedo', 'Santander', 'Sp Gijon', 'Tenerife', 'Zaragoza']),
        "Eredivisie": sorted(['Ajax', 'Almere City', 'AZ Alkmaar', 'Feyenoord', 'For Sittard', 'Go Ahead Eagles', 'Groningen',
                              'Heerenveen', 'Heracles', 'NAC Breda', 'Nijmegen', 'PSV Eindhoven', 'Sparta Rotterdam',
                              'Twente', 'Utrecht', 'Waalwijk', 'Willem II', 'Zwolle']),
        "Bundesliga": sorted(['Augsburg', 'Bayern Munich', 'Bochum', 'Dortmund', 'Ein Frankfurt', 'Freiburg',
                              'Heidenheim', 'Hoffenheim', 'Holstein Kiel', 'Leverkusen', 'M\'gladbach', 'Mainz', 'RB Leipzig',
                              'St Pauli', 'Stuttgart', 'Union Berlin', 'Werder Bremen', 'Wolfsburg']),
        "Bundesliga2": sorted(['Hamburg', 'Schalke 04', 'Hannover', 'Elversberg', 'Kaiserslautern', 'St Pauli', 'Osnabruck',
                               'Karlsruhe', 'Wehen', 'Magdeburg', 'Fortuna Dusseldorf', 'Hertha', 'Braunschweig', 'Holstein Kiel',
                               'Greuther Furth', 'Paderborn', 'Hansa Rostock', 'Nurnberg']),
        "Scottish League": sorted(['Aberdeen', 'Celtic', 'Dundee', 'Dundee United', 'Hearts', 'Hibernian', 'Kilmarnock',
                                    'Motherwell', 'Rangers', 'Ross County', 'St Johnstone', 'St Mirren']),
        "Belgium League": sorted(['Anderlecht', 'Antwerp', 'Beerschot VA', 'Cercle Brugge', 'Charleroi', 'Club Brugge',
                                  'Dender', 'Genk', 'Gent', 'Kortrijk', 'Mechelen', 'Oud-Heverlee Leuven', 'St Truiden',
                                  'St. Gilloise', 'Standard', 'Westerlo']),
        "Portuguese League": sorted(['Arouca', 'AVS', 'Benfica', 'Boavista', 'Casa Pia', 'Estoril', 'Estrela',
                                     'Famalicao', 'Farense', 'Gil Vicente', 'Guimaraes', 'Moreirense', 'Nacional',
                                     'Porto', 'Rio Ave', 'Santa Clara', 'Sp Braga', 'Sp Lisbon']),
        "Turkish League": sorted(['Ad. Demirspor', 'Alanyaspor', 'Antalyaspor', 'Besiktas', 'Bodrumspor', 'Buyuksehyr',
                                  'Eyupspor', 'Fenerbahce', 'Galatasaray', 'Gaziantep', 'Goztep', 'Hatayspor',
                                  'Kasimpasa', 'Kayserispor', 'Konyaspor', 'Rizespor', 'Samsunspor', 'Sivasspor',
                                  'Trabzonspor']),
        "Greece League": sorted(['AEK', 'Asteras Tripolis', 'Athens Kallithea', 'Atromitos', 'Lamia', 'Levadeiakos',
                                 'OFI Crete', 'Olympiakos', 'PAOK', 'Panathinaikos', 'Panetolikos',
                                 'Panserraikos', 'Volos NFC', 'Aris']),
    },
    'Others': {
        "Switzerland League": sorted(['Basel','Grasshoppers','Lausanne','Lugano','Luzern', 'Servette','Sion',
                                      'St. Gallen','Winterthur','Young Boys','Yverdon', 'Zurich']),
        "Denmark League": sorted(['Aarhus', 'Midtjylland', 'Nordsjaelland', 'Aalborg', 'Silkeborg', 'Sonderjyske',
                                  'Vejle', 'Randers FC', 'Viborg', 'Brondby', 'Lyngby', 'FC Copenhagen']),
        "Austria League": sorted(['Grazer AK', 'Salzburg', 'Altach', 'Tirol', 'Hartberg', 'LASK', 'Wolfsberger AC',
                                  'A. Klagenfurt', 'BW Linz', 'Austria Vienna', 'SK Rapid', 'Sturm Graz']),
        "Mexico League": sorted(['Puebla', 'Santos Laguna', 'Queretaro', 'Club Tijuana', 'Juarez', 'Atlas', 'Atl. San Luis',
                                 'Club America', 'Guadalajara Chivas', 'Toluca', 'Tigres UANL', 'Necaxa', 'Cruz Azul', 'Mazatlan FC',
                                 'UNAM Pumas', 'Club Leon', 'Pachuca', 'Monterrey']),
        "Russia League": sorted(['Lokomotiv Moscow', 'Akron Togliatti', 'Krylya Sovetov', 'Zenit', 'Dynamo Moscow', 'Fakel Voronezh',
                                 'FK Rostov', 'CSKA Moscow', 'Orenburg', 'Spartak Moscow', 'Akhmat Grozny', 'Krasnodar', 'Khimki', 'Dynamo Makhachkala',
                                 'Pari NN', 'Rubin Kazan']),
        "Romania League": sorted(['Farul Constanta', 'Unirea Slobozia', 'FC Hermannstadt', 'Univ. Craiova', 'Sepsi Sf. Gheorghe', 'Poli Iasi', 'UTA Arad',
                                 'FC Rapid Bucuresti', 'FCSB', 'U. Cluj', 'CFR Cluj', 'Din. Bucuresti', 'FC Botosani', 'Otelul', 'Petrolul', 'Gloria Buzau'])
    }
}

# Helper functions (compute_mean_for_teams_v1, compute_mean_for_teams_v2,
# Function to compute the mean of head-to-head stats for the selected teams (for first dataset)
def compute_mean_for_teams_v1(home_team, away_team):
    h2h_data = data1[(data1['HomeTeam'] == home_team) & (data1['AwayTeam'] == away_team)]
    if h2h_data.empty:
        st.error(f"No historical data available with {home_team} as the home team and {away_team} as the away team.")
        return None

    h2h_data = h2h_data.drop(columns=['FTR', 'Date', 'HomeTeam', 'AwayTeam'], errors='ignore')
    h2h_data['HTR'] = h2h_data['HTR'].replace({'H': 1, 'D': 2, 'A': 3})
    mean_data = h2h_data.mean(numeric_only=True)

    if 'HTR' in mean_data:
        if 0 <= mean_data['HTR'] <= 1.4:
            mean_data['HTR'] = 'H'
        elif 1.5 <= mean_data['HTR'] <= 2.4:
            mean_data['HTR'] = 'D'
        elif 2.5 <= mean_data['HTR'] <= 3.4:
            mean_data['HTR'] = 'A'

    input_data = pd.DataFrame([mean_data])
    model_features = model1.feature_names_in_
    for feature in model_features:
        if feature not in input_data.columns:
            input_data[feature] = 0
    input_data = input_data[model_features]

    return input_data

# Function to compute the mean of head-to-head stats for the selected teams (for second dataset)
def compute_mean_for_teams_v2(home, away):
    h2h_data = data2[(data2['Home'] == home) & (data2['Away'] == away)]
    if h2h_data.empty:
        st.error(f"No historical data available with {home} as the home team and {away} as the away team.")
        return None

    h2h_data = h2h_data.drop(columns=["Res","Date","Country","League","Season","Time"], errors='ignore')
    mean_data = h2h_data.mean(numeric_only=True)

    input_data = pd.DataFrame([mean_data])
    model_features = model2.feature_names_in_
    for feature in model_features:
        if feature not in input_data.columns:
            input_data[feature] = 0
    input_data = input_data[model_features]

    return input_data
# calculate_probabilities_v1, calculate_probabilities_v2,
def calculate_probabilities_v1(home_team, away_team):
    h2h_data = data1[(data1['HomeTeam'] == home_team) & (data1['AwayTeam'] == away_team)]

    if h2h_data.empty:
        st.error(f"No historical data available with {home_team} as the home team and {away_team} as the away team.")
        return None

    total_matches = len(h2h_data)
    home_wins = (h2h_data['FTR'] == 'H').sum()
    draws = (h2h_data['FTR'] == 'D').sum()
    away_wins = (h2h_data['FTR'] == 'A').sum()

    home_win_prob = (home_wins / total_matches) * 100 if total_matches > 0 else 0
    draw_prob = (draws / total_matches) * 100 if total_matches > 0 else 0
    away_win_prob = (away_wins / total_matches) * 100 if total_matches > 0 else 0

    return {
        "Home Team Win": home_win_prob,
        "Draw": draw_prob,
        "Away Team Win": away_win_prob
    }

# Function to calculate win probabilities based on historical data (for second dataset)
def calculate_probabilities_v2(home, away):
    h2h_data = data2[(data2['Home'] == home) & (data2['Away'] == away)]

    if h2h_data.empty:
        st.error(f"No historical data available with {home} as the home team and {away} as the away team.")
        return None

    total_matches = len(h2h_data)
    home_wins = (h2h_data['Res'] == 'H').sum()
    draws = (h2h_data['Res'] == 'D').sum()
    away_wins = (h2h_data['Res'] == 'A').sum()

    home_win_prob = (home_wins / total_matches) * 100 if total_matches > 0 else 0
    draw_prob = (draws / total_matches) * 100 if total_matches > 0 else 0
    away_win_prob = (away_wins / total_matches) * 100 if total_matches > 0 else 0

    return {
        "Home Team Win": home_win_prob,
        "Draw": draw_prob,
        "Away Team Win": away_win_prob
    }
# determine_final_prediction - same as your Streamlit code)
# Adjusted function to handle model vs. probability discrepancies
def determine_final_prediction(model_prediction, probabilities):
    if 0.5 <= model_prediction <= 1.4:
        model_outcome = "Home Team Win"
    elif 1.5 <= model_prediction <= 2.4:
        model_outcome = "Draw"
    elif 2.5 <= model_prediction <= 3.4:
        model_outcome = "Away Team Win"
    else:
        return "❗ Invalid prediction value"

    highest_prob_outcome = max(probabilities, key=probabilities.get)
    highest_prob_value = probabilities[highest_prob_outcome]
    tied_outcomes = [outcome for outcome, prob in probabilities.items() if prob == highest_prob_value]

    if model_outcome == highest_prob_outcome:
        return model_outcome
    elif len(tied_outcomes) > 1:
        if model_outcome == "Home Team Win" and "Draw" in tied_outcomes:
            return "Home or Draw"
        elif model_outcome == "Home Team Win" and "Away Team Win" in tied_outcomes:
            return "Home or Away"
        elif model_outcome == "Draw" and "Home Team Win" in tied_outcomes:
            return "Draw or Home"
        elif model_outcome == "Draw" and "Away Team Win" in tied_outcomes:
            return "Draw or Away"
        elif model_outcome == "Away Team Win" and "Draw" in tied_outcomes:
            return "Away or Draw"
        elif model_outcome == "Away Team Win" and "Home Team Win" in tied_outcomes:
            return "Away or Home"
        else:
            return model_outcome
    else:
        if model_outcome == "Home Team Win":
            if highest_prob_outcome == "Draw":
                return "Home or Draw"
            elif highest_prob_outcome == "Away Team Win":
                return "Home or Away"
        elif model_outcome == "Away Team Win":
            if highest_prob_outcome == "Draw":
                return "Away or Draw"
            elif highest_prob_outcome == "Home Team Win":
                return "Away or Home"
        elif model_outcome == "Draw":
            if highest_prob_outcome == "Home Team Win":
                return "Draw or Home"
            elif highest_prob_outcome == "Away Team Win":
                return "Draw or Away"

    return "❗ Unexpected outcome"
# Prediction functions
def predict_v1(home_team, away_team):
    probabilities = calculate_probabilities_v1(home_team, away_team)
    if probabilities is None:
        return None

    input_data = compute_mean_for_teams_v1(home_team, away_team)
    if input_data is None:
        return None

    model_prediction = model1.predict(input_data)[0]
    final_prediction = determine_final_prediction(model_prediction, probabilities)

    # Create plot
    colors = {
        "Home Team Win": "green",
        "Draw": "yellow",
        "Away Team Win": "red",
    }
    fig = px.bar(
        x=list(probabilities.keys()),
        y=list(probabilities.values()),
        labels={'x': 'Outcome', 'y': 'Probability (%)'},
        title="Match Outcome Probabilities",
        color=list(probabilities.keys()),
        color_discrete_map=colors
    )
    plot_html = fig.to_html(full_html=False)

    # Prepare historical probabilities HTML
    hist_prob_html = '<div style="font-size: 20px; color: #FF4500; font-weight: bold; text-align: center;">Historical Probabilities:</div>'
    for outcome, prob in probabilities.items():
        hist_prob_html += f'<div style="font-size: 18px; text-align: center;">{outcome}: {prob:.2f}%</div>'

    return {
        'final_prediction': final_prediction,
        'plot_html': plot_html,
        'hist_prob_html': hist_prob_html
    }

# Similar predict_v2 function for 'Others' category
def predict_v2(home_team, away_team):
    probabilities = calculate_probabilities_v2(home_team, away_team)
    if probabilities is None:
        return None

    input_data = compute_mean_for_teams_v2(home_team, away_team)
    if input_data is None:
        return None

    model_prediction = model2.predict(input_data)[0]
    final_prediction = determine_final_prediction(model_prediction, probabilities)

    # Create plot
    colors = {
        "Home Team Win": "green",
        "Draw": "yellow",
        "Away Team Win": "red",
    }
    fig = px.bar(
        x=list(probabilities.keys()),
        y=list(probabilities.values()),
        labels={'x': 'Outcome', 'y': 'Probability (%)'},
        title="Match Outcome Probabilities",
        color=list(probabilities.keys()),
        color_discrete_map=colors
    )
    plot_html = fig.to_html(full_html=False)

    # Prepare historical probabilities HTML
    hist_prob_html = '<div style="font-size: 20px; color: #FF4500; font-weight: bold; text-align: center;">Historical Probabilities:</div>'
    for outcome, prob in probabilities.items():
        hist_prob_html += f'<div style="font-size: 18px; text-align: center;">{outcome}: {prob:.2f}%</div>'

    return {
        'final_prediction': final_prediction,
        'plot_html': plot_html,
        'hist_prob_html': hist_prob_html
    }

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        category = request.form.get('category')
        league_name = request.form.get('league_name')
        home_team = request.form.get('home_team')
        away_team = request.form.get('away_team')

        session['selections'] = {
            'category': category,
            'league_name': league_name,
            'home_team': home_team,
            'away_team': away_team
        }

        if category == "Others":
            result = predict_v2(home_team, away_team)
        else:
            result = predict_v1(home_team, away_team)

        if result:
            return render_template('result.html', result=result)
        else:
            return render_template('index.html',
                                   leagues=leagues,
                                   error="No historical data available for these teams")

    return render_template('index.html', leagues=leagues)

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port)