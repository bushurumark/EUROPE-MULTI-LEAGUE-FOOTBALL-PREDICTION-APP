# -*- coding: utf-8 -*-
"""App4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18J0v4HBA2wTGlFIwX5gOvVXU5htTLje5
"""

#pip install streamlit

import streamlit as st
import pandas as pd
import joblib
import gdown
import plotly.express as px
from sklearn.metrics import accuracy_score, confusion_matrix, ConfusionMatrixDisplay

# Download the model from Google Drive and cache it to avoid re-downloading
@st.cache_data
def download_model():
    url = 'https://drive.google.com/uc?id=1uchT3FyZuGOBv9LTbxbm9gTynoWZ8HGk'
    output = 'model.pkl'
    gdown.download(url, output, quiet=False)
    model = joblib.load(output)
    return model

# Load data from Google Drive and cache it
@st.cache_data
def load_data():
    url = 'https://drive.google.com/uc?id=1XQhKB_utut1FUIpVV3_F6WrQq3514kmj'
    output = 'football_data.xlsx'
    gdown.download(url, output, quiet=False)
    return pd.read_excel(output)

# Load model and data
model = download_model()
data = load_data()

# Function to compute the mean of head-to-head stats for the selected teams
def compute_mean_for_teams(home_team, away_team):
    h2h_data = data[(data['HomeTeam'] == home_team) & (data['AwayTeam'] == away_team)]
    if h2h_data.empty:
        st.error(f"No historical data available with {home_team} as the home team and {away_team} as the away team.")
        return None

    h2h_data = h2h_data.drop(columns=['FTR', 'Date', 'HomeTeam', 'AwayTeam'], errors='ignore')
    h2h_data['HTR'] = h2h_data['HTR'].replace({'H': 1, 'D': 2, 'A': 3})
    mean_data = h2h_data.mean(numeric_only=True)

    if 'HTR' in mean_data:
        if 0 <= mean_data['HTR'] <= 1.4:
            mean_data['HTR'] = 'H'
        elif 1.5 <= mean_data['HTR'] <= 2.4:
            mean_data['HTR'] = 'D'
        elif 2.5 <= mean_data['HTR'] <= 3.4:
            mean_data['HTR'] = 'A'

    input_data = pd.DataFrame([mean_data])
    model_features = model.feature_names_in_
    for feature in model_features:
        if feature not in input_data.columns:
            input_data[feature] = 0
    input_data = input_data[model_features]

    return input_data

# Function to calculate win probabilities based on historical data
def calculate_probabilities(home_team, away_team):
    # Filter historical matches
    h2h_data = data[(data['HomeTeam'] == home_team) & (data['AwayTeam'] == away_team)]

    if h2h_data.empty:
        st.error(f"No historical data available with {home_team} as the home team and {away_team} as the away team.")
        return None

    # Count outcomes
    total_matches = len(h2h_data)
    home_wins = (h2h_data['FTR'] == 'H').sum()  # Home team wins
    draws = (h2h_data['FTR'] == 'D').sum()      # Draws
    away_wins = (h2h_data['FTR'] == 'A').sum()  # Away team wins

    # Calculate probabilities
    home_win_prob = (home_wins / total_matches) * 100 if total_matches > 0 else 0
    draw_prob = (draws / total_matches) * 100 if total_matches > 0 else 0
    away_win_prob = (away_wins / total_matches) * 100 if total_matches > 0 else 0

    return {
        "Home Team Win": home_win_prob,
        "Draw": draw_prob,
        "Away Team Win": away_win_prob
    }
# Adjusted function to handle model vs. probability discrepancies
def determine_final_prediction(model_prediction, probabilities):
    # Map model predictions to outcomes
    if 0.5 <= model_prediction <= 1.4:
        model_outcome = "Home Team Win"
    elif 1.5 <= model_prediction <= 2.4:
        model_outcome = "Draw"
    elif 2.5 <= model_prediction <= 3.4:
        model_outcome = "Away Team Win"
    else:
        return "‚ùó Invalid prediction value"
    # Find the historical outcome with the highest probability
    highest_prob_outcome = max(probabilities, key=probabilities.get)
    highest_prob_value = probabilities[highest_prob_outcome]
    # Handle scenarios where probabilities are tied
    tied_outcomes = [outcome for outcome, prob in probabilities.items() if prob == highest_prob_value]

    # Case 1: Model and highest probability match
    if model_outcome == highest_prob_outcome:
        return model_outcome
    # Case 2: If probabilities tie, adjust based on model's prediction
    elif len(tied_outcomes) > 1:
        if model_outcome == "Home Team Win" and "Draw" in tied_outcomes:
            return "Home or Draw"  # Prioritize the model prediction
        elif model_outcome == "Home Team Win" and "Away Team Win" in tied_outcomes:
            return "Home or Away"  # Prioritize the model prediction
        elif model_outcome == "Draw" and "Home Team Win" in tied_outcomes:
            return "Draw or Home"
        elif model_outcome == "Draw" and "Away Team Win" in tied_outcomes:
            return "Draw or Away"
        elif model_outcome == "Away Team Win" and "Draw" in tied_outcomes:
            return "Away or Draw"
        elif model_outcome == "Away Team Win" and "Home Team Win" in tied_outcomes:
            return "Away or Home"
        else:
            return model_outcome  # Return the model's prediction if tie resolution doesn't apply.
    # Case 3: Model prediction doesn't match the highest probability
    else:
        if model_outcome == "Home Team Win":
            if highest_prob_outcome == "Draw":
                return "Home or Draw"
            elif highest_prob_outcome == "Away Team Win":
                return "Home or Away"
        elif model_outcome == "Away Team Win":
            if highest_prob_outcome == "Draw":
                return "Away or Draw"
            elif highest_prob_outcome == "Home Team Win":
                return "Away or Home"
        elif model_outcome == "Draw":
            if highest_prob_outcome == "Home Team Win":
                return "Draw or Home"
            elif highest_prob_outcome == "Away Team Win":
                return "Draw or Away"

    return "‚ùó Unexpected outcome"
    # Decision logic
    if model_outcome == highest_historical_outcome:
        # Model's prediction aligns with the highest probability outcome
        return model_outcome
    elif model_outcome == "Home Team Win":
        if highest_historical_outcome == "Draw":
            return "Home or Draw"
        elif highest_historical_outcome == "Away Team Win":
            return "Home or Away"
    elif model_outcome == "Away Team Win":
        if highest_historical_outcome == "Draw":
            return "Away or Draw"
        elif highest_historical_outcome == "Home Team Win":
            return "Away or Home"
    elif model_outcome == "Draw":
        if highest_historical_outcome == "Home Team Win":
            return "Draw or Home"
        elif highest_historical_outcome == "Away Team Win":
            return "Draw or Away"

    return "‚ùó Unexpected outcome"
# Prediction function with final logic
def predict_with_custom_logic(home_team, away_team):
    # Calculate historical probabilities
    probabilities = calculate_probabilities(home_team, away_team)
    if probabilities is None:
        return
    # Generate input data for the model
    input_data = compute_mean_for_teams(home_team, away_team)
    if input_data is None:
        return

    # Model prediction
    model_prediction = model.predict(input_data)[0]
    # Determine the final prediction
    final_prediction = determine_final_prediction(model_prediction, probabilities)

    # Display results
    st.markdown(f'<div class="prediction-result">üèÜ Final Prediction: {final_prediction}</div>', unsafe_allow_html=True)

    # Visualize probabilities
    colors = {
        "Home Team Win": "green",
        "Draw": "yellow",
        "Away Team Win": "red",
    }
    fig = px.bar(
        x=list(probabilities.keys()),
        y=list(probabilities.values()),
        labels={'x': 'Outcome', 'y': 'Probability (%)'},
        title="Match Outcome Probabilities",
        color=list(probabilities.keys()),
        color_discrete_map=colors
    )
    st.plotly_chart(fig)

    # Display probabilities
    st.markdown('<div style="font-size: 20px; color: #FF4500; font-weight: bold; text-align: center;">Historical Probabilities:</div>', unsafe_allow_html=True)
    for outcome, prob in probabilities.items():
        st.markdown(f'<div style="font-size: 18px; text-align: center;">{outcome}: {prob:.2f}%</div>', unsafe_allow_html=True)

# CSS Styling
st.markdown("""
    <style>
    /* Set the app background to blue */
    .stApp {
        background-color: #0000FF;
    }
    /* Title styling */
    .title {
        color: #32CD32;
        text-align: center;
        font-size: 40px;
    }
    /* Dropdown label styling */
    label {
        color: red !important; /* Red color for labels */
        font-weight: bold;
    }
    /* Dropdown styling */
    .stSelectbox {
        color: #00008B;
        background-color: #ADD8E6;
        border-radius: 10px;
        border: 2px solid #32CD32;
    }
    /* Button styling */
    .stButton button {
        background-color: #FFD700;
        color: black;
        font-size: 20px;
        border-radius: 10px;
        padding: 10px 20px;
    }
    /* Prediction result styling */
    .prediction-result {
        color: #FF4500;
        font-size: 30px;
        text-align: center;
        font-weight: bold;
    }
    </style>
    """, unsafe_allow_html=True)

# Main app function
def main():
    st.markdown('<div class="title">MULTI-LEAGUE FOOTBALL PREDICTION APP</div>', unsafe_allow_html=True)

    leagues = {
        "Premier League": sorted(['Arsenal', 'Aston Villa', 'Bournemouth', 'Brentford', 'Brighton', 'Chelsea', 'Crystal Palace',
                                  'Everton', 'Fulham', 'Ipswich', 'Leicester', 'Liverpool', 'Man City', 'Man United', 'Newcastle',
                                  "Nott'm Forest", 'Southampton', 'Tottenham', 'West Ham', 'Wolves']),
        "English Championship" : sorted(['Blackburn', 'Derby', 'Preston', 'Sheffield United', 'Cardiff', 'Sunderland','Hull',
                                         'Bristol City', 'Leeds', 'Portsmouth', 'Middlesbrough', 'Swansea','Millwall', 'Watford',
                                         'Oxford', 'Norwich', 'QPR', 'West Brom', 'Stoke','Coventry', 'Sheffield Weds', 'Plymouth',
                                         'Luton', 'Burnley']),
        "Serie A": sorted(['Atalanta', 'Bologna', 'Cagliari', 'Como', 'Empoli', 'Fiorentina', 'Genoa', 'Inter',
                           'Juventus', 'Lazio', 'Lecce', 'Milan', 'Monza', 'Napoli', 'Parma', 'Roma', 'Torino',
                           'Udinese', 'Venezia', 'Verona']),
        "Serie B": sorted(['Bari', 'Brescia', 'Carrarese', 'Catanzaro', 'Cesena', 'Cittadella', 'Cosenza', 'Cremonese',
                           'Frosinone', 'Juve Stabia', 'Mantova', 'Modena', 'Palermo', 'Pisa', 'Reggiana', 'Salernitana',
                           'Sampdoria', 'Sassuolo', 'Spezia', 'Sudtirol']),

        "Ligue1": sorted(['Angers', 'Auxerre', 'Brest', 'Lens', 'Le Havre', 'Lille', 'Lyon', 'Marseille',
                          'Monaco', 'Montpellier', 'Nantes', 'Nice', 'Paris SG', 'Reims', 'Rennes',
                          'St Etienne', 'Strasbourg', 'Toulouse']),
        "French Division Two": sorted(['Ajaccio', 'Rodez', 'Amiens', 'Red Star', 'Clermont', 'Pau FC', 'Dunkerque', 
                                       'Annecy', 'Grenoble', 'Laval', 'Guingamp', 'Troyes', 'Caen', 'Paris FC', 
                                       'Martigues', 'Lorient', 'Metz', 'Bastia']),
        "La Liga": sorted(['Alaves', 'Ath Bilbao', 'Ath Madrid', 'Barcelona', 'Betis', 'Celta', 'Espanol', 'Getafe',
                           'Girona', 'Las Palmas', 'Leganes', 'Mallorca', 'Osasuna', 'Real Madrid', 'Sevilla', 'Sociedad',
                           'Valencia', 'Valladolid', 'Vallecano', 'Villarreal']),
        "La Liga2": sorted(['Albacete', 'Almeria', 'Burgos', 'Cadiz', 'Cartagena', 'Castellon', 'Cordoba', 'Eibar',
                            'Eldense', 'Elche', 'Ferrol', 'Granada', 'Huesca', 'La Coruna', 'Levante', 'Malaga',
                            'Mirandes', 'Oviedo', 'Santander', 'Sp Gijon', 'Tenerife', 'Zaragoza']),

        "Eredivisie": sorted(['Ajax', 'Almere City', 'AZ Alkmaar', 'Feyenoord', 'For Sittard', 'Go Ahead Eagles', 'Groningen',
                              'Heerenveen', 'Heracles', 'NAC Breda', 'Nijmegen', 'PSV Eindhoven', 'Sparta Rotterdam',
                              'Twente', 'Utrecht', 'Waalwijk', 'Willem II', 'Zwolle']),
        "Bundesliga": sorted(['Augsburg', 'Bayern Munich', 'Bochum', 'Dortmund', 'Ein Frankfurt', 'Freiburg',
                              'Heidenheim', 'Hoffenheim', 'Holstein Kiel', 'Leverkusen', 'M\'gladbach', 'Mainz', 'RB Leipzig',
                              'St Pauli', 'Stuttgart', 'Union Berlin', 'Werder Bremen', 'Wolfsburg']),
        "Germany Division Two": sorted(['Hamburg', 'Schalke 04', 'Hannover', 'Elversberg', 'Kaiserslautern', 'St Pauli', 'Osnabruck', 
                                        'Karlsruhe', 'Wehen', 'Magdeburg', 'Fortuna Dusseldorf', 'Hertha', 'Braunschweig', 'Holstein Kiel', 
                                        'Greuther Furth', 'Paderborn', 'Hansa Rostock', 'Nurnberg']),
        "Scottish League": sorted(['Aberdeen', 'Celtic', 'Dundee', 'Dundee United', 'Hearts', 'Hibernian', 'Kilmarnock',
                                    'Motherwell', 'Rangers', 'Ross County', 'St Johnstone', 'St Mirren']),
        "Belgium League": sorted(['Anderlecht', 'Antwerp', 'Beerschot VA', 'Cercle Brugge', 'Charleroi', 'Club Brugge',
                                  'Dender', 'Genk', 'Gent', 'Kortrijk', 'Mechelen', 'Oud-Heverlee Leuven', 'St Truiden',
                                  'St. Gilloise', 'Standard', 'Westerlo']),
        "Portuguese League": sorted(['Arouca', 'AVS', 'Benfica', 'Boavista', 'Casa Pia', 'Estoril', 'Estrela',
                                     'Famalicao', 'Farense', 'Gil Vicente', 'Guimaraes', 'Moreirense', 'Nacional',
                                     'Porto', 'Rio Ave', 'Santa Clara', 'Sp Braga', 'Sp Lisbon']),
        "Turkish League": sorted(['Ad. Demirspor', 'Alanyaspor', 'Antalyaspor', 'Besiktas', 'Bodrumspor', 'Buyuksehyr',
                                  'Eyupspor', 'Fenerbahce', 'Galatasaray', 'Gaziantep', 'Goztep', 'Hatayspor',
                                  'Kasimpasa', 'Kayserispor', 'Konyaspor', 'Rizespor', 'Samsunspor', 'Sivasspor',
                                  'Trabzonspor']),
        "Greece League": sorted(['AEK', 'Asteras Tripolis', 'Athens Kallithea', 'Atromitos', 'Lamia', 'Levadeiakos',
                                 'OFI Crete', 'Olympiakos', 'PAOK', 'Panathinaikos', 'Panetolikos',
                                 'Panserraikos', 'Volos NFC', 'Aris'])
    }

    league_name = st.selectbox("Select a League", options=list(leagues.keys()))
    home_team = st.selectbox("Select a Home Team", options=leagues[league_name])
    away_team = st.selectbox("Select an Away Team", options=leagues[league_name])

    if st.button("Predict Match Outcome"):
        predict_with_custom_logic(home_team, away_team)

if __name__ == '__main__':
    main()
