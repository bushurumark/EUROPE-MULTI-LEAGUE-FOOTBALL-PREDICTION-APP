# -*- coding: utf-8 -*-
"""App2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11Ktuff_BVrxkstMDXUpx0woqFHSnR4HD
"""

!pip install streamlit --no-deps

import streamlit as st
import pandas as pd
import joblib
import gdown
import plotly.express as px
from sklearn.metrics import accuracy_score, confusion_matrix, ConfusionMatrixDisplay

# Download the models from Google Drive and cache them to avoid re-downloading
@st.cache_data
def download_models():
    # Download first model
    url1 = 'https://drive.google.com/uc?id=1uchT3FyZuGOBv9LTbxbm9gTynoWZ8HGk'
    output1 = 'model1.pkl'
    gdown.download(url1, output1, quiet=False)
    model1 = joblib.load(output1)

    # Download second model
    url2 = 'https://drive.google.com/uc?id=10zj3fK-2YYjgQGj3HvPWHc6PtXTmyX61'
    output2 = 'model2.pkl'
    gdown.download(url2, output2, quiet=False)
    model2 = joblib.load(output2)

    return model1, model2

# Load data from Google Drive and cache it
@st.cache_data
def load_data():
    # Load first dataset
    url1 = 'https://drive.google.com/uc?id=1Xu3bpecWmhd0ZE9P2oLaalce9nTBV5Zx'
    output1 = 'football_data1.csv'
    gdown.download(url1, output1, quiet=False)
    data1 = pd.read_csv(output1)

    # Load second dataset
    url2 = 'https://drive.google.com/uc?id=1ZtmML4-kYhVffOSxRLw6QhA9uUDqlqoy'
    output2 = 'football_data2.csv'
    gdown.download(url2, output2, quiet=False)
    data2 = pd.read_csv(output2)

    return data1, data2

# Load models and data
model1, model2 = download_models()
data1, data2 = load_data()

# Function to compute the mean of head-to-head stats for the selected teams (for first dataset)
def compute_mean_for_teams_v1(home_team, away_team):
    h2h_data = data1[(data1['HomeTeam'] == home_team) & (data1['AwayTeam'] == away_team)]
    if h2h_data.empty:
        st.error(f"No historical data available with {home_team} as the home team and {away_team} as the away team.")
        return None

    h2h_data = h2h_data.drop(columns=['FTR', 'Date', 'HomeTeam', 'AwayTeam'], errors='ignore')
    h2h_data['HTR'] = h2h_data['HTR'].replace({'H': 1, 'D': 2, 'A': 3})
    mean_data = h2h_data.mean(numeric_only=True)

    if 'HTR' in mean_data:
        if 0 <= mean_data['HTR'] <= 1.4:
            mean_data['HTR'] = 'H'
        elif 1.5 <= mean_data['HTR'] <= 2.4:
            mean_data['HTR'] = 'D'
        elif 2.5 <= mean_data['HTR'] <= 3.4:
            mean_data['HTR'] = 'A'

    input_data = pd.DataFrame([mean_data])
    model_features = model1.feature_names_in_
    for feature in model_features:
        if feature not in input_data.columns:
            input_data[feature] = 0
    input_data = input_data[model_features]

    return input_data

# Function to compute the mean of head-to-head stats for the selected teams (for second dataset)
def compute_mean_for_teams_v2(home, away):
    h2h_data = data2[(data2['Home'] == home) & (data2['Away'] == away)]
    if h2h_data.empty:
        st.error(f"No historical data available with {home} as the home team and {away} as the away team.")
        return None

    h2h_data = h2h_data.drop(columns=["Res","Date","Country","League","Season","Time"], errors='ignore')
    mean_data = h2h_data.mean(numeric_only=True)

    input_data = pd.DataFrame([mean_data])
    model_features = model2.feature_names_in_
    for feature in model_features:
        if feature not in input_data.columns:
            input_data[feature] = 0
    input_data = input_data[model_features]

    return input_data

# Function to calculate win probabilities based on historical data (for first dataset)
def calculate_probabilities_v1(home_team, away_team):
    h2h_data = data1[(data1['HomeTeam'] == home_team) & (data1['AwayTeam'] == away_team)]

    if h2h_data.empty:
        st.error(f"No historical data available with {home_team} as the home team and {away_team} as the away team.")
        return None

    total_matches = len(h2h_data)
    home_wins = (h2h_data['FTR'] == 'H').sum()
    draws = (h2h_data['FTR'] == 'D').sum()
    away_wins = (h2h_data['FTR'] == 'A').sum()

    home_win_prob = (home_wins / total_matches) * 100 if total_matches > 0 else 0
    draw_prob = (draws / total_matches) * 100 if total_matches > 0 else 0
    away_win_prob = (away_wins / total_matches) * 100 if total_matches > 0 else 0

    return {
        "Home Team Win": home_win_prob,
        "Draw": draw_prob,
        "Away Team Win": away_win_prob
    }

# Function to calculate win probabilities based on historical data (for second dataset)
def calculate_probabilities_v2(home, away):
    h2h_data = data2[(data2['Home'] == home) & (data2['Away'] == away)]

    if h2h_data.empty:
        st.error(f"No historical data available with {home} as the home team and {away} as the away team.")
        return None

    total_matches = len(h2h_data)
    home_wins = (h2h_data['Res'] == 'H').sum()
    draws = (h2h_data['Res'] == 'D').sum()
    away_wins = (h2h_data['Res'] == 'A').sum()

    home_win_prob = (home_wins / total_matches) * 100 if total_matches > 0 else 0
    draw_prob = (draws / total_matches) * 100 if total_matches > 0 else 0
    away_win_prob = (away_wins / total_matches) * 100 if total_matches > 0 else 0

    return {
        "Home Team Win": home_win_prob,
        "Draw": draw_prob,
        "Away Team Win": away_win_prob
    }

# Adjusted function to handle model vs. probability discrepancies
def determine_final_prediction(model_prediction, probabilities):
    if 0.5 <= model_prediction <= 1.4:
        model_outcome = "Home Team Win"
    elif 1.5 <= model_prediction <= 2.4:
        model_outcome = "Draw"
    elif 2.5 <= model_prediction <= 3.4:
        model_outcome = "Away Team Win"
    else:
        return "‚ùó Invalid prediction value"

    highest_prob_outcome = max(probabilities, key=probabilities.get)
    highest_prob_value = probabilities[highest_prob_outcome]
    tied_outcomes = [outcome for outcome, prob in probabilities.items() if prob == highest_prob_value]

    if model_outcome == highest_prob_outcome:
        return model_outcome
    elif len(tied_outcomes) > 1:
        if model_outcome == "Home Team Win" and "Draw" in tied_outcomes:
            return "Home or Draw"
        elif model_outcome == "Home Team Win" and "Away Team Win" in tied_outcomes:
            return "Home or Away"
        elif model_outcome == "Draw" and "Home Team Win" in tied_outcomes:
            return "Draw or Home"
        elif model_outcome == "Draw" and "Away Team Win" in tied_outcomes:
            return "Draw or Away"
        elif model_outcome == "Away Team Win" and "Draw" in tied_outcomes:
            return "Away or Draw"
        elif model_outcome == "Away Team Win" and "Home Team Win" in tied_outcomes:
            return "Away or Home"
        else:
            return model_outcome
    else:
        if model_outcome == "Home Team Win":
            if highest_prob_outcome == "Draw":
                return "Home or Draw"
            elif highest_prob_outcome == "Away Team Win":
                return "Home or Away"
        elif model_outcome == "Away Team Win":
            if highest_prob_outcome == "Draw":
                return "Away or Draw"
            elif highest_prob_outcome == "Home Team Win":
                return "Away or Home"
        elif model_outcome == "Draw":
            if highest_prob_outcome == "Home Team Win":
                return "Draw or Home"
            elif highest_prob_outcome == "Away Team Win":
                return "Draw or Away"

    return "‚ùó Unexpected outcome"

# Prediction function for first set of leagues
def predict_with_custom_logic_v1(home_team, away_team):
    probabilities = calculate_probabilities_v1(home_team, away_team)
    if probabilities is None:
        return

    input_data = compute_mean_for_teams_v1(home_team, away_team)
    if input_data is None:
        return

    model_prediction = model1.predict(input_data)[0]
    final_prediction = determine_final_prediction(model_prediction, probabilities)

    st.markdown(f'<div class="prediction-result">üèÜ Final Prediction: {final_prediction}</div>', unsafe_allow_html=True)

    colors = {
        "Home Team Win": "green",
        "Draw": "yellow",
        "Away Team Win": "red",
    }
    fig = px.bar(
        x=list(probabilities.keys()),
        y=list(probabilities.values()),
        labels={'x': 'Outcome', 'y': 'Probability (%)'},
        title="Match Outcome Probabilities",
        color=list(probabilities.keys()),
        color_discrete_map=colors
    )
    st.plotly_chart(fig)

    st.markdown('<div style="font-size: 20px; color: #FF4500; font-weight: bold; text-align: center;">Historical Probabilities:</div>', unsafe_allow_html=True)
    for outcome, prob in probabilities.items():
        st.markdown(f'<div style="font-size: 18px; text-align: center;">{outcome}: {prob:.2f}%</div>', unsafe_allow_html=True)

# Prediction function for second set of leagues
def predict_with_custom_logic_v2(home_team, away_team):
    probabilities = calculate_probabilities_v2(home_team, away_team)
    if probabilities is None:
        return

    input_data = compute_mean_for_teams_v2(home_team, away_team)
    if input_data is None:
        return

    model_prediction = model2.predict(input_data)[0]
    final_prediction = determine_final_prediction(model_prediction, probabilities)

    st.markdown(f'<div class="prediction-result">üèÜ Final Prediction: {final_prediction}</div>', unsafe_allow_html=True)

    colors = {
        "Home Team Win": "green",
        "Draw": "yellow",
        "Away Team Win": "red",
    }
    fig = px.bar(
        x=list(probabilities.keys()),
        y=list(probabilities.values()),
        labels={'x': 'Outcome', 'y': 'Probability (%)'},
        title="Match Outcome Probabilities",
        color=list(probabilities.keys()),
        color_discrete_map=colors
    )
    st.plotly_chart(fig)

    st.markdown('<div style="font-size: 20px; color: #FF4500; font-weight: bold; text-align: center;">Historical Probabilities:</div>', unsafe_allow_html=True)
    for outcome, prob in probabilities.items():
        st.markdown(f'<div style="font-size: 18px; text-align: center;">{outcome}: {prob:.2f}%</div>', unsafe_allow_html=True)

# CSS Styling
st.markdown("""
    <style>
    /* Set the app background to blue */
    .stApp {
        background-color: #0000FF;
    }
    /* Title styling */
    .title {
        color: #32CD32;
        text-align: center;
        font-size: 40px;
    }
    /* Dropdown label styling */
    label {
        color: red !important; /* Red color for labels */
        font-weight: bold;
    }
    /* Dropdown styling */
    .stSelectbox {
        color: #00008B;
        background-color: #ADD8E6;
        border-radius: 10px;
        border: 2px solid #32CD32;
    }
    /* Button styling */
    .stButton button {
        background-color: #FFD700;
        color: black;
        font-size: 20px;
        border-radius: 10px;
        padding: 10px 20px;
    }
    /* Prediction result styling */
    .prediction-result {
        color: #FF4500;
        font-size: 30px;
        text-align: center;
        font-weight: bold;
    }
    </style>
    """, unsafe_allow_html=True)

# Main app function
def main():
    st.markdown('<div class="title">FOOTBALL PREDICTION APP</div>', unsafe_allow_html=True)

    # Define all leagues from both apps
    leagues = {
        'European Leagues': {
        "Premier League": sorted(['Arsenal', 'Aston Villa', 'Bournemouth', 'Brentford', 'Brighton', 'Chelsea', 'Crystal Palace',
                                  'Everton', 'Fulham', 'Ipswich', 'Leicester', 'Liverpool', 'Man City', 'Man United', 'Newcastle',
                                  "Nott'm Forest", 'Southampton', 'Tottenham', 'West Ham', 'Wolves']),
        "English Championship": sorted(['Blackburn', 'Derby', 'Preston', 'Sheffield United', 'Cardiff', 'Sunderland','Hull',
                                         'Bristol City', 'Leeds', 'Portsmouth', 'Middlesbrough', 'Swansea','Millwall', 'Watford',
                                         'Oxford', 'Norwich', 'QPR', 'West Brom', 'Stoke','Coventry', 'Sheffield Weds', 'Plymouth',
                                         'Luton', 'Burnley']),
        "Serie A": sorted(['Atalanta', 'Bologna', 'Cagliari', 'Como', 'Empoli', 'Fiorentina', 'Genoa', 'Inter',
                           'Juventus', 'Lazio', 'Lecce', 'Milan', 'Monza', 'Napoli', 'Parma', 'Roma', 'Torino',
                           'Udinese', 'Venezia', 'Verona']),
        "Serie B": sorted(['Bari', 'Brescia', 'Carrarese', 'Catanzaro', 'Cesena', 'Cittadella', 'Cosenza', 'Cremonese',
                           'Frosinone', 'Juve Stabia', 'Mantova', 'Modena', 'Palermo', 'Pisa', 'Reggiana', 'Salernitana',
                           'Sampdoria', 'Sassuolo', 'Spezia', 'Sudtirol']),
        "Ligue1": sorted(['Angers', 'Auxerre', 'Brest', 'Lens', 'Le Havre', 'Lille', 'Lyon', 'Marseille',
                          'Monaco', 'Montpellier', 'Nantes', 'Nice', 'Paris SG', 'Reims', 'Rennes',
                          'St Etienne', 'Strasbourg', 'Toulouse']),
        "Ligue2": sorted(['Ajaccio', 'Rodez', 'Amiens', 'Red Star', 'Clermont', 'Pau FC', 'Dunkerque',
                          'Annecy', 'Grenoble', 'Laval', 'Guingamp', 'Troyes', 'Caen', 'Paris FC',
                          'Martigues', 'Lorient', 'Metz', 'Bastia']),
        "La Liga": sorted(['Alaves', 'Ath Bilbao', 'Ath Madrid', 'Barcelona', 'Betis', 'Celta', 'Espanol', 'Getafe',
                           'Girona', 'Las Palmas', 'Leganes', 'Mallorca', 'Osasuna', 'Real Madrid', 'Sevilla', 'Sociedad',
                           'Valencia', 'Valladolid', 'Vallecano', 'Villarreal']),
        "La Liga2": sorted(['Albacete', 'Almeria', 'Burgos', 'Cadiz', 'Cartagena', 'Castellon', 'Cordoba', 'Eibar',
                            'Eldense', 'Elche', 'Ferrol', 'Granada', 'Huesca', 'La Coruna', 'Levante', 'Malaga',
                            'Mirandes', 'Oviedo', 'Santander', 'Sp Gijon', 'Tenerife', 'Zaragoza']),
        "Eredivisie": sorted(['Ajax', 'Almere City', 'AZ Alkmaar', 'Feyenoord', 'For Sittard', 'Go Ahead Eagles', 'Groningen',
                              'Heerenveen', 'Heracles', 'NAC Breda', 'Nijmegen', 'PSV Eindhoven', 'Sparta Rotterdam',
                              'Twente', 'Utrecht', 'Waalwijk', 'Willem II', 'Zwolle']),
        "Bundesliga": sorted(['Augsburg', 'Bayern Munich', 'Bochum', 'Dortmund', 'Ein Frankfurt', 'Freiburg',
                              'Heidenheim', 'Hoffenheim', 'Holstein Kiel', 'Leverkusen', 'M\'gladbach', 'Mainz', 'RB Leipzig',
                              'St Pauli', 'Stuttgart', 'Union Berlin', 'Werder Bremen', 'Wolfsburg']),
        "Bundesliga2": sorted(['Hamburg', 'Schalke 04', 'Hannover', 'Elversberg', 'Kaiserslautern', 'St Pauli', 'Osnabruck',
                               'Karlsruhe', 'Wehen', 'Magdeburg', 'Fortuna Dusseldorf', 'Hertha', 'Braunschweig', 'Holstein Kiel',
                               'Greuther Furth', 'Paderborn', 'Hansa Rostock', 'Nurnberg']),
        "Scottish League": sorted(['Aberdeen', 'Celtic', 'Dundee', 'Dundee United', 'Hearts', 'Hibernian', 'Kilmarnock',
                                    'Motherwell', 'Rangers', 'Ross County', 'St Johnstone', 'St Mirren']),
        "Belgium League": sorted(['Anderlecht', 'Antwerp', 'Beerschot VA', 'Cercle Brugge', 'Charleroi', 'Club Brugge',
                                  'Dender', 'Genk', 'Gent', 'Kortrijk', 'Mechelen', 'Oud-Heverlee Leuven', 'St Truiden',
                                  'St. Gilloise', 'Standard', 'Westerlo']),
        "Portuguese League": sorted(['Arouca', 'AVS', 'Benfica', 'Boavista', 'Casa Pia', 'Estoril', 'Estrela',
                                     'Famalicao', 'Farense', 'Gil Vicente', 'Guimaraes', 'Moreirense', 'Nacional',
                                     'Porto', 'Rio Ave', 'Santa Clara', 'Sp Braga', 'Sp Lisbon']),
        "Turkish League": sorted(['Ad. Demirspor', 'Alanyaspor', 'Antalyaspor', 'Besiktas', 'Bodrumspor', 'Buyuksehyr',
                                  'Eyupspor', 'Fenerbahce', 'Galatasaray', 'Gaziantep', 'Goztep', 'Hatayspor',
                                  'Kasimpasa', 'Kayserispor', 'Konyaspor', 'Rizespor', 'Samsunspor', 'Sivasspor',
                                  'Trabzonspor']),
        "Greece League": sorted(['AEK', 'Asteras Tripolis', 'Athens Kallithea', 'Atromitos', 'Lamia', 'Levadeiakos',
                                 'OFI Crete', 'Olympiakos', 'PAOK', 'Panathinaikos', 'Panetolikos',
                                 'Panserraikos', 'Volos NFC', 'Aris']),
        },
        'Others': {
        "Switzerland League": sorted(['Basel','Grasshoppers','Lausanne','Lugano','Luzern', 'Servette','Sion',
                                      'St. Gallen','Winterthur','Young Boys','Yverdon', 'Zurich']),
        "Denmark League": sorted(['Aarhus', 'Midtjylland', 'Nordsjaelland', 'Aalborg', 'Silkeborg', 'Sonderjyske',
                                  'Vejle', 'Randers FC', 'Viborg', 'Brondby', 'Lyngby', 'FC Copenhagen']),
        "Austria League": sorted(['Grazer AK', 'Salzburg', 'Altach', 'Tirol', 'Hartberg', 'LASK', 'Wolfsberger AC',
                                  'A. Klagenfurt', 'BW Linz', 'Austria Vienna', 'SK Rapid', 'Sturm Graz']),
        "Mexico League": sorted(['Puebla', 'Santos Laguna', 'Queretaro', 'Club Tijuana', 'Juarez', 'Atlas', 'Atl. San Luis',
                                 'Club America', 'Guadalajara Chivas', 'Toluca', 'Tigres UANL', 'Necaxa', 'Cruz Azul', 'Mazatlan FC',
                                 'UNAM Pumas', 'Club Leon', 'Pachuca', 'Monterrey']),
        "Russia League": sorted(['Lokomotiv Moscow', 'Akron Togliatti', 'Krylya Sovetov', 'Zenit', 'Dynamo Moscow', 'Fakel Voronezh',
                                 'FK Rostov', 'CSKA Moscow', 'Orenburg', 'Spartak Moscow', 'Akhmat Grozny', 'Krasnodar', 'Khimki', 'Dynamo Makhachkala',
                                 'Pari NN', 'Rubin Kazan']),
        "Romania League": sorted(['Farul Constanta', 'Unirea Slobozia', 'FC Hermannstadt', 'Univ. Craiova', 'Sepsi Sf. Gheorghe', 'Poli Iasi', 'UTA Arad',
                                 'FC Rapid Bucuresti', 'FCSB', 'U. Cluj', 'CFR Cluj', 'Din. Bucuresti', 'FC Botosani', 'Otelul', 'Petrolul', 'Gloria Buzau'])
        }
    }
    #select category (European or Others)
    category = st.selectbox("Select Category", options=list(leagues.keys()))
    #Select specific league within that category
    league_name = st.selectbox("Select a League", options=list(leagues[category].keys()))
    #Select teams from the chosen league
    home_team = st.selectbox("Select Home Team", options=leagues[category][league_name])
    away_team = st.selectbox("Select Away Team", options=leagues[category][league_name])

    if st.button("Predict Match Outcome"):
        # Determine which dataset to use based on the league selected
        if category == "Others":
            predict_with_custom_logic_v2(home_team, away_team)
        else:
            predict_with_custom_logic_v1(home_team, away_team)

if __name__ == '__main__':
    main()