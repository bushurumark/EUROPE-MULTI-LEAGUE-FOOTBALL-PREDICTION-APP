# -*- coding: utf-8 -*-
"""backend.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AFcXC9gv0fSDEZ4bGyF6a8X6YAl0fbPn
"""

#!pip install streamlit
# backend.py
import os
import pandas as pd
import joblib
import requests

# Model and data URLs
MODEL1_URL = "https://raw.githubusercontent.com/bushurumark/EUROPE-MULTI-LEAGUE-FOOTBALL-PREDICTION-APP/main/Models/model1.pkl"
MODEL2_URL = "https://raw.githubusercontent.com/bushurumark/EUROPE-MULTI-LEAGUE-FOOTBALL-PREDICTION-APP/main/Models/model2.pkl"
DATA1_URL = "https://raw.githubusercontent.com/bushurumark/EUROPE-MULTI-LEAGUE-FOOTBALL-PREDICTION-APP/main/Datasets/football_data1.csv"
DATA2_URL = "https://raw.githubusercontent.com/bushurumark/EUROPE-MULTI-LEAGUE-FOOTBALL-PREDICTION-APP/main/Datasets/football_data2.csv"

# Download files if not present
def download_file_if_needed(url, filename):
    if not os.path.exists(filename):
        response = requests.get(url)
        with open(filename, "wb") as f:
            f.write(response.content)

def download_models():
    download_file_if_needed(MODEL1_URL, "model1.pkl")
    download_file_if_needed(MODEL2_URL, "model2.pkl")
    model1 = joblib.load("model1.pkl")
    model2 = joblib.load("model2.pkl")
    return model1, model2

def load_data():
    download_file_if_needed(DATA1_URL, "football_data1.csv")
    download_file_if_needed(DATA2_URL, "football_data2.csv")
    data1 = pd.read_csv("football_data1.csv")
    data2 = pd.read_csv("football_data2.csv")
    return data1, data2

def compute_mean_for_teams_v1(home, away, data, model):
    h2h = data[(data['HomeTeam'] == home) & (data['AwayTeam'] == away)]
    if h2h.empty:
        return None
    h2h = h2h.drop(columns=['FTR', 'Date', 'HomeTeam', 'AwayTeam'], errors='ignore')
    h2h['HTR'] = h2h['HTR'].replace({'H': 1, 'D': 2, 'A': 3})
    mean = h2h.mean(numeric_only=True)
    if 'HTR' in mean:
        if 0 <= mean['HTR'] <= 1.4:
            mean['HTR'] = 'H'
        elif 1.5 <= mean['HTR'] <= 2.4:
            mean['HTR'] = 'D'
        elif 2.5 <= mean['HTR'] <= 3.4:
            mean['HTR'] = 'A'
    input_df = pd.DataFrame([mean])
    for f in model.feature_names_in_:
        if f not in input_df:
            input_df[f] = 0
    return input_df[model.feature_names_in_]

def compute_mean_for_teams_v2(home, away, data, model):
    h2h = data[(data['Home'] == home) & (data['Away'] == away)]
    if h2h.empty:
        return None
    h2h = h2h.drop(columns=["Res", "Date", "Country", "League", "Season", "Time"], errors='ignore')
    mean = h2h.mean(numeric_only=True)
    input_df = pd.DataFrame([mean])
    for f in model.feature_names_in_:
        if f not in input_df:
            input_df[f] = 0
    return input_df[model.feature_names_in_]

def calculate_probabilities_v1(home, away, data):
    h2h = data[(data['HomeTeam'] == home) & (data['AwayTeam'] == away)]
    if h2h.empty:
        return None
    total = len(h2h)
    return {
        "Home Team Win": (h2h['FTR'] == 'H').sum() / total * 100,
        "Draw": (h2h['FTR'] == 'D').sum() / total * 100,
        "Away Team Win": (h2h['FTR'] == 'A').sum() / total * 100,
    }

def calculate_probabilities_v2(home, away, data):
    h2h = data[(data['Home'] == home) & (data['Away'] == away)]
    if h2h.empty:
        return None
    total = len(h2h)
    return {
        "Home Team Win": (h2h['Res'] == 'H').sum() / total * 100,
        "Draw": (h2h['Res'] == 'D').sum() / total * 100,
        "Away Team Win": (h2h['Res'] == 'A').sum() / total * 100,
    }

def determine_final_prediction(pred, probs):
    if 0.5 <= pred <= 1.4:
        model_outcome = "Home Team Win"
    elif 1.5 <= pred <= 2.4:
        model_outcome = "Draw"
    elif 2.5 <= pred <= 3.4:
        model_outcome = "Away Team Win"
    else:
        return "❗ Invalid prediction"
    highest = max(probs, key=probs.get)
    if model_outcome == highest:
        return model_outcome
    tied = [k for k, v in probs.items() if v == probs[highest]]
    if len(tied) > 1:
        return f"{model_outcome} or {tied[1]}" if tied[1] != model_outcome else f"{tied[0]} or {model_outcome}"
    return f"{model_outcome} or {highest}"

def predict_with_confidence(model, input_df):
    try:
        proba = model.predict_proba(input_df)[0]
        return proba
    except:
        return None

def get_head_to_head_history(home, away, data, version="v1"):
    if version == "v1":
        h2h = data[(data['HomeTeam'] == home) & (data['AwayTeam'] == away)]
        if 'Date' in h2h.columns:
            h2h['Date'] = pd.to_datetime(h2h['Date'], errors='coerce')
        return h2h[['Date', 'FTR']].dropna()
    else:
        h2h = data[(data['Home'] == home) & (data['Away'] == away)]
        if 'Date' in h2h.columns:
            h2h['Date'] = pd.to_datetime(h2h['Date'], errors='coerce')
        return h2h[['Date', 'Res']].dropna()

def get_recent_team_form(home, away, data, version="v1"):
    if version == "v1":
        home_matches = data[data['HomeTeam'] == home].sort_values(by='Date', ascending=False).head(5)
        away_matches = data[data['AwayTeam'] == away].sort_values(by='Date', ascending=False).head(5)
        home_form = "".join(home_matches['FTR'].fillna("-").values)
        away_form = "".join(away_matches['FTR'].fillna("-").values)
    else:
        home_matches = data[data['Home'] == home].sort_values(by='Date', ascending=False).head(5)
        away_matches = data[data['Away'] == away].sort_values(by='Date', ascending=False).head(5)
        home_form = "".join(home_matches['Res'].fillna("-").values)
        away_form = "".join(away_matches['Res'].fillna("-").values)
    return home_form, away_form

def get_head_to_head_form(home_team, away_team, data, version="v1"):
    if version == "v2":
        home_col, away_col, result_col = "Home", "Away", "Res"
    else:
        home_col, away_col, result_col = "HomeTeam", "AwayTeam", "FTR"

    df = data[[home_col, away_col, result_col, "Date"]].copy()
    df["Date"] = pd.to_datetime(df["Date"], errors="coerce")
    df = df.dropna(subset=["Date"])

    h2h = df[
        ((df[home_col] == home_team) & (df[away_col] == away_team)) |
        ((df[home_col] == away_team) & (df[away_col] == home_team))
    ].sort_values("Date", ascending=False).head(5)

    home_form, away_form = [], []

    for _, row in h2h.iterrows():
        result = row[result_col]
        h, a = row[home_col], row[away_col]

        if home_team == h:
            home_form.append("W" if result == "H" else "D" if result == "D" else "L")
        elif home_team == a:
            home_form.append("W" if result == "A" else "D" if result == "D" else "L")

        if away_team == h:
            away_form.append("W" if result == "H" else "D" if result == "D" else "L")
        elif away_team == a:
            away_form.append("W" if result == "A" else "D" if result == "D" else "L")

    return "".join(home_form), "".join(away_form)

# ✅ NEW: Team's recent form (last 5 matches) from perspective of W/D/L
def get_team_recent_form(team_name, data, version="v1"):
    """
    Returns a team's recent form (last 5 matches) in terms of W/D/L,
    based on whether they played at home or away.
    """
    if version == "v2":
        home_col, away_col, result_col = "Home", "Away", "Res"
    else:
        home_col, away_col, result_col = "HomeTeam", "AwayTeam", "FTR"

    if not all(col in data.columns for col in [home_col, away_col, result_col, "Date"]):
        return "❗ Missing required columns"

    df = data[[home_col, away_col, result_col, "Date"]].copy()
    df["Date"] = pd.to_datetime(df["Date"], errors="coerce")
    df = df.dropna(subset=["Date"])

    recent_matches = df[(df[home_col] == team_name) | (df[away_col] == team_name)]
    recent_matches = recent_matches.sort_values("Date", ascending=False).head(5)

    form = []
    for _, row in recent_matches.iterrows():
        result = row[result_col]
        is_home = row[home_col] == team_name

        if result == "D":
            form.append("D")
        elif (result == "H" and is_home) or (result == "A" and not is_home):
            form.append("W")
        else:
            form.append("L")

    return "".join(form)





