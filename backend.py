# -*- coding: utf-8 -*-
"""backend.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AFcXC9gv0fSDEZ4bGyF6a8X6YAl0fbPn
"""

#!pip install streamlit

# backend.py
import os
import pandas as pd
import joblib
import requests

MODEL1_URL = "https://raw.githubusercontent.com/bushurumark/EUROPE-MULTI-LEAGUE-FOOTBALL-PREDICTION-APP/main/Models/model1.pkl"
MODEL2_URL = "https://raw.githubusercontent.com/bushurumark/EUROPE-MULTI-LEAGUE-FOOTBALL-PREDICTION-APP/main/Models/model2.pkl"
DATA1_URL = "https://raw.githubusercontent.com/bushurumark/EUROPE-MULTI-LEAGUE-FOOTBALL-PREDICTION-APP/main/Datasets/football_data1.csv"
DATA2_URL = "https://raw.githubusercontent.com/bushurumark/EUROPE-MULTI-LEAGUE-FOOTBALL-PREDICTION-APP/main/Datasets/football_data2.csv"

def download_file_if_needed(url, filename):
    if not os.path.exists(filename):
        response = requests.get(url)
        with open(filename, "wb") as f:
            f.write(response.content)

def download_models():
    download_file_if_needed(MODEL1_URL, "model1.pkl")
    download_file_if_needed(MODEL2_URL, "model2.pkl")
    model1 = joblib.load("model1.pkl")
    model2 = joblib.load("model2.pkl")
    return model1, model2

def load_data():
    download_file_if_needed(DATA1_URL, "football_data1.csv")
    download_file_if_needed(DATA2_URL, "football_data2.csv")
    data1 = pd.read_csv("football_data1.csv")
    data2 = pd.read_csv("football_data2.csv")
    return data1, data2

def compute_mean_for_teams_v1(home, away, data, model):
    h2h = data[(data['HomeTeam'] == home) & (data['AwayTeam'] == away)]
    if h2h.empty:
        return None
    h2h = h2h.drop(columns=['FTR', 'Date', 'HomeTeam', 'AwayTeam'], errors='ignore')
    h2h['HTR'] = h2h['HTR'].replace({'H': 1, 'D': 2, 'A': 3})
    mean = h2h.mean(numeric_only=True)
    if 'HTR' in mean:
        if 0 <= mean['HTR'] <= 1.4:
            mean['HTR'] = 'H'
        elif 1.5 <= mean['HTR'] <= 2.4:
            mean['HTR'] = 'D'
        elif 2.5 <= mean['HTR'] <= 3.4:
            mean['HTR'] = 'A'
    input_df = pd.DataFrame([mean])
    for f in model.feature_names_in_:
        if f not in input_df:
            input_df[f] = 0
    return input_df[model.feature_names_in_]

def compute_mean_for_teams_v2(home, away, data, model):
    h2h = data[(data['Home'] == home) & (data['Away'] == away)]
    if h2h.empty:
        return None
    h2h = h2h.drop(columns=["Res", "Date", "Country", "League", "Season", "Time"], errors='ignore')
    mean = h2h.mean(numeric_only=True)
    input_df = pd.DataFrame([mean])
    for f in model.feature_names_in_:
        if f not in input_df:
            input_df[f] = 0
    return input_df[model.feature_names_in_]

def calculate_probabilities_v1(home, away, data):
    h2h = data[(data['HomeTeam'] == home) & (data['AwayTeam'] == away)]
    if h2h.empty:
        return None
    total = len(h2h)
    return {
        "Home Team Win": (h2h['FTR'] == 'H').sum() / total * 100,
        "Draw": (h2h['FTR'] == 'D').sum() / total * 100,
        "Away Team Win": (h2h['FTR'] == 'A').sum() / total * 100,
    }

def calculate_probabilities_v2(home, away, data):
    h2h = data[(data['Home'] == home) & (data['Away'] == away)]
    if h2h.empty:
        return None
    total = len(h2h)
    return {
        "Home Team Win": (h2h['Res'] == 'H').sum() / total * 100,
        "Draw": (h2h['Res'] == 'D').sum() / total * 100,
        "Away Team Win": (h2h['Res'] == 'A').sum() / total * 100,
    }

def determine_final_prediction(pred, probs):
    if 0.5 <= pred <= 1.4:
        model_outcome = "Home Team Win"
    elif 1.5 <= pred <= 2.4:
        model_outcome = "Draw"
    elif 2.5 <= pred <= 3.4:
        model_outcome = "Away Team Win"
    else:
        return "❗ Invalid prediction"
    highest = max(probs, key=probs.get)
    if model_outcome == highest:
        return model_outcome
    tied = [k for k, v in probs.items() if v == probs[highest]]
    if len(tied) > 1:
        return f"{model_outcome} or {tied[1]}" if tied[1] != model_outcome else f"{tied[0]} or {model_outcome}"
    return f"{model_outcome} or {highest}"

def predict_with_confidence(model, input_df):
    try:
        proba = model.predict_proba(input_df)[0]
        return proba  # Returns array like [0.6, 0.25, 0.15]
    except:
        return None

def get_head_to_head_history(home, away, data, version="v1"):
    if version == "v1":
        h2h = data[(data['HomeTeam'] == home) & (data['AwayTeam'] == away)]
        if 'Date' in h2h.columns:
            h2h['Date'] = pd.to_datetime(h2h['Date'], errors='coerce')
        return h2h[['Date', 'FTR']].dropna()
    else:
        h2h = data[(data['Home'] == home) & (data['Away'] == away)]
        if 'Date' in h2h.columns:
            h2h['Date'] = pd.to_datetime(h2h['Date'], errors='coerce')
        return h2h[['Date', 'Res']].dropna()


