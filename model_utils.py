# -*- coding: utf-8 -*-
"""model_utils.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pG3fP0ZkEJcmXf97m5-w6aK2BhKB5Awf
"""

import pandas as pd
import logging
from analytics import get_column_names  # ✅ import the helper

def align_features(input_df, model):
    for f in model.feature_names_in_:
        if f not in input_df:
            input_df[f] = 0
    return input_df[model.feature_names_in_]

def compute_mean_for_teams(home, away, data, model, version="v1"):
    home_col, away_col, result_col = get_column_names(version)  # ✅ dynamic columns
    h2h = data[(data[home_col] == home) & (data[away_col] == away)]
    if h2h.empty:
        return None
    h2h = h2h.drop(columns=[result_col, "Date", "Country", "League", "Season", "Time"], errors='ignore')
    if version == "v1" and 'HTR' in h2h:
        h2h['HTR'] = h2h['HTR'].replace({'H': 1, 'D': 2, 'A': 3})
    mean = h2h.mean(numeric_only=True)
    if 'HTR' in mean:
        if 0 <= mean['HTR'] <= 1.4:
            mean['HTR'] = 'H'
        elif 1.5 <= mean['HTR'] <= 2.4:
            mean['HTR'] = 'D'
        elif 2.5 <= mean['HTR'] <= 3.4:
            mean['HTR'] = 'A'
    input_df = pd.DataFrame([mean])
    return align_features(input_df, model)

def calculate_probabilities(home, away, data, version="v1"):
    home_col, away_col, result_col = get_column_names(version)  # ✅ dynamic columns
    outcome_map = {"H": "Home Team Win", "D": "Draw", "A": "Away Team Win"}
    h2h = data[(data[home_col] == home) & (data[away_col] == away)]
    if h2h.empty:
        return None
    value_counts = h2h[result_col].value_counts(normalize=True) * 100
    return {outcome_map.get(k, k): round(v, 2) for k, v in value_counts.items()}

def predict_with_confidence(model, input_df):
    try:
        proba = model.predict_proba(input_df)[0]
        pred_idx = proba.argmax()
        labels = model.classes_
        return labels[pred_idx], proba[pred_idx], dict(zip(labels, proba))
    except Exception as e:
        logging.error(f"Prediction error: {e}")
        return None, None, None

def determine_final_prediction(pred, probs):
    if 0.5 <= pred <= 1.4:
        model_outcome = "Home Team Win"
    elif 1.5 <= pred <= 2.4:
        model_outcome = "Draw"
    elif 2.5 <= pred <= 3.4:
        model_outcome = "Away Team Win"
    else:
        return "❗ Invalid prediction"

    highest = max(probs, key=probs.get)
    if model_outcome == highest:
        return model_outcome

    tied = [k for k, v in probs.items() if v == probs[highest]]
    if len(tied) > 1:
        return f"{model_outcome} or {tied[1]}" if tied[1] != model_outcome else f"{tied[0]} or {model_outcome}"
    return f"{model_outcome} or {highest}"

