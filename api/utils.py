# -*- coding: utf-8 -*-
"""utilis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cQ4AG3inLfPrMbt_WBZhMki_HXFyMMmn
"""

import pandas as pd
import joblib
import gdown
from typing import Dict, Optional, Tuple, List
import numpy as np

# --- Model/Data Loading ---
def download_models() -> Tuple:
    """Downloads and loads both ML models from Google Drive."""
    url1 = 'https://drive.google.com/uc?id=1uchT3FyZuGOBv9LTbxbm9gTynoWZ8HGk'
    gdown.download(url1, 'model1.pkl', quiet=False)
    model1 = joblib.load('model1.pkl')

    url2 = 'https://drive.google.com/uc?id=10zj3fK-2YYjgQGj3HvPWHc6PtXTmyX61'
    gdown.download(url2, 'model2.pkl', quiet=False)
    model2 = joblib.load('model2.pkl')

    return model1, model2

def load_data() -> Tuple[pd.DataFrame, pd.DataFrame]:
    """Downloads and loads both datasets from Google Drive."""
    url1 = 'https://drive.google.com/uc?id=1Xu3bpecWmhd0ZE9P2oLaalce9nTBV5Zx'
    gdown.download(url1, 'football_data1.csv', quiet=False)
    data1 = pd.read_csv('football_data1.csv')

    url2 = 'https://drive.google.com/uc?id=1ZtmML4-kYhVffOSxRLw6QhA9uUDqlqoy'
    gdown.download(url2, 'football_data2.csv', quiet=False)
    data2 = pd.read_csv('football_data2.csv')

    return data1, data2

# --- Core Prediction Logic ---
def predict_match(
    home_team: str,
    away_team: str,
    league_type: str,
    model1, model2,
    data1: pd.DataFrame,
    data2: pd.DataFrame
) -> Dict:
    """
    Orchestrates the full prediction pipeline.
    Returns: {
        "prediction": str,
        "probabilities": dict,
        "model_used": str
    }
    """
    if league_type == "European":
        probabilities = calculate_probabilities_v1(home_team, away_team, data1)
        input_data = compute_mean_for_teams_v1(home_team, away_team, data1, model1.feature_names_in_)
        model_pred = model1.predict(input_data)[0]
        model_name = "European League Model"
    else:
        probabilities = calculate_probabilities_v2(home_team, away_team, data2)
        input_data = compute_mean_for_teams_v2(home_team, away_team, data2, model2.feature_names_in_)
        model_pred = model2.predict(input_data)[0]
        model_name = "Other Leagues Model"

    if probabilities is None or input_data is None:
        raise ValueError("No historical data for these teams")

    return {
        "prediction": determine_final_prediction(model_pred, probabilities),
        "probabilities": probabilities,
        "model_used": model_name
    }

# --- Feature Engineering ---
def compute_mean_for_teams_v1(
    home_team: str,
    away_team: str,
    data: pd.DataFrame,
    model_features: List[str]
) -> Optional[pd.DataFrame]:
    """
    Computes mean stats for European league teams.
    Returns None if no historical matches exist.
    """
    h2h_data = data[(data['HomeTeam'] == home_team) & (data['AwayTeam'] == away_team)]
    if h2h_data.empty:
        return None

    # Preprocessing
    h2h_data = h2h_data.drop(columns=['FTR', 'Date', 'HomeTeam', 'AwayTeam'], errors='ignore')
    h2h_data['HTR'] = h2h_data['HTR'].replace({'H': 1, 'D': 2, 'A': 3})

    # Feature engineering
    mean_data = h2h_data.mean(numeric_only=True)
    if 'HTR' in mean_data:
        mean_data['HTR'] = np.select(
            [
                (0 <= mean_data['HTR'] <= 1.4),
                (1.5 <= mean_data['HTR'] <= 2.4),
                (2.5 <= mean_data['HTR'] <= 3.4)
            ],
            ['H', 'D', 'A'],
            default='?'
        )

    # Ensure all model features are present
    input_data = pd.DataFrame([mean_data])
    for feature in model_features:
        if feature not in input_data.columns:
            input_data[feature] = 0

    return input_data[model_features]

def compute_mean_for_teams_v2(
    home_team: str,
    away_team: str,
    data: pd.DataFrame,
    model_features: List[str]
) -> Optional[pd.DataFrame]:
    """
    Computes mean stats for non-European leagues.
    Returns None if no historical matches exist.
    """
    h2h_data = data[(data['Home'] == home_team) & (data['Away'] == away_team)]
    if h2h_data.empty:
        return None

    # Drop non-feature columns
    h2h_data = h2h_data.drop(
        columns=["Res", "Date", "Country", "League", "Season", "Time"],
        errors='ignore'
    )

    # Feature engineering
    mean_data = h2h_data.mean(numeric_only=True)
    input_data = pd.DataFrame([mean_data])

    # Ensure all model features are present
    for feature in model_features:
        if feature not in input_data.columns:
            input_data[feature] = 0

    return input_data[model_features]

# --- Probability Calculations ---
def calculate_probabilities_v1(
    home_team: str,
    away_team: str,
    data: pd.DataFrame
) -> Optional[Dict[str, float]]:
    """
    Calculates win/draw/loss probabilities for European leagues.
    Returns None if no historical matches exist.
    """
    h2h_data = data[(data['HomeTeam'] == home_team) & (data['AwayTeam'] == away_team)]
    if h2h_data.empty:
        return None

    total = len(h2h_data)
    return {
        "Home Team Win": (h2h_data['FTR'] == 'H').sum() / total * 100,
        "Draw": (h2h_data['FTR'] == 'D').sum() / total * 100,
        "Away Team Win": (h2h_data['FTR'] == 'A').sum() / total * 100
    }

def calculate_probabilities_v2(
    home_team: str,
    away_team: str,
    data: pd.DataFrame
) -> Optional[Dict[str, float]]:
    """
    Calculates win/draw/loss probabilities for other leagues.
    Returns None if no historical matches exist.
    """
    h2h_data = data[(data['Home'] == home_team) & (data['Away'] == away_team)]
    if h2h_data.empty:
        return None

    total = len(h2h_data)
    return {
        "Home Team Win": (h2h_data['Res'] == 'H').sum() / total * 100,
        "Draw": (h2h_data['Res'] == 'D').sum() / total * 100,
        "Away Team Win": (h2h_data['Res'] == 'A').sum() / total * 100
    }

# --- Prediction Resolution ---
def determine_final_prediction(
    model_prediction: float,
    probabilities: Dict[str, float]
) -> str:
    """
    Resolves conflicts between model output and historical probabilities.
    Returns a human-readable prediction string.
    """
    # Model outcome mapping
    if 0.5 <= model_prediction <= 1.4:
        model_outcome = "Home Team Win"
    elif 1.5 <= model_prediction <= 2.4:
        model_outcome = "Draw"
    elif 2.5 <= model_prediction <= 3.4:
        model_outcome = "Away Team Win"
    else:
        return "❗ Invalid prediction value"

    # Probability analysis
    max_prob_outcome = max(probabilities, key=probabilities.get)
    max_prob_value = probabilities[max_prob_outcome]
    tied_outcomes = [k for k, v in probabilities.items() if v == max_prob_value]

    # Consensus check
    if model_outcome == max_prob_outcome:
        return model_outcome
    elif len(tied_outcomes) > 1:
        return f"{model_outcome} or {tied_outcomes[0]}"
    else:
        return f"{model_outcome} or {max_prob_outcome}"